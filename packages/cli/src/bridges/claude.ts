import type { Bridge, Rule, ProjectConfig } from './types.js';

function filterRules(rules: Rule[]): Rule[] {
  return rules.filter((r) => r.enabled && r.severity !== 'info');
}

function groupByScope(rules: Rule[]): Map<string, Rule[]> {
  const groups = new Map<string, Rule[]>();
  for (const rule of rules) {
    const existing = groups.get(rule.scope);
    if (existing) {
      existing.push(rule);
    } else {
      groups.set(rule.scope, [rule]);
    }
  }
  return groups;
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

function buildMarkdown(rules: Rule[]): string {
  const timestamp = new Date().toISOString().replace(/\.\d{3}Z$/, 'Z');
  const lines: string[] = [
    '<!-- Generated by dev-workflows. Do not edit manually. -->',
    `<!-- Source: .dwf/ | Compiled: ${timestamp} -->`,
    '',
    '# Project Rules',
  ];

  const filtered = filterRules(rules);
  const grouped = groupByScope(filtered);

  for (const [scope, scopeRules] of grouped) {
    lines.push('', `## ${capitalize(scope)}`);
    for (const rule of scopeRules) {
      const contentLines = rule.content.split('\n');
      const first = contentLines[0];
      if (first !== undefined) {
        lines.push('', `- ${first}`);
      }
      for (let i = 1; i < contentLines.length; i++) {
        const line = contentLines[i];
        if (line !== undefined) {
          lines.push(`  ${line}`);
        }
      }
    }
  }

  lines.push('');
  return lines.join('\n');
}

export const claudeBridge: Bridge = {
  id: 'claude',
  outputPaths: ['CLAUDE.md'],

  compile(rules: Rule[], _config: ProjectConfig): Map<string, string> {
    const output = new Map<string, string>();
    output.set('CLAUDE.md', buildMarkdown(rules));
    return output;
  },
};
