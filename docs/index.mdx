---
title: "dev-workflows"
description: "Write rules once, compile to every AI editor"
---

# Write once, **run everywhere**

A single source of truth for your development rules. Compile to any AI editor.

## The Problem

If you use Claude Code, Cursor, and Gemini CLI, you maintain the same rules in three different files with three slightly different formats. They always drift apart.

## The Solution

```bash
npx dev-workflows init                    # create .dwf/ with config
npx dev-workflows add typescript/strict   # install a rule from the registry
npx dev-workflows compile                 # generate CLAUDE.md, .cursor/rules, GEMINI.md
```

Define rules once in YAML, compile to each editor's native format.

<Columns cols={3}>
  <Card title="CLAUDE.md" icon="robot" href="/concepts/bridges">
    Claude Code
  </Card>
  <Card title=".cursor/rules" icon="code" href="/concepts/bridges">
    Cursor
  </Card>
  <Card title="GEMINI.md" icon="star" href="/concepts/bridges">
    Gemini CLI
  </Card>
</Columns>

## Rules Registry

Start with battle-tested rules instead of writing from scratch. Browse with `devw add --list` or run `devw add` for interactive selection.

<Columns cols={3}>
  <Card title="typescript/strict" href="/commands/add">
    No any, explicit returns, union types over enums
  </Card>
  <Card title="javascript/react" href="/commands/add">
    Hooks rules, component patterns, naming
  </Card>
  <Card title="javascript/nextjs" href="/commands/add">
    App Router, RSC, server actions
  </Card>
  <Card title="css/tailwind" href="/commands/add">
    Utility-first, no custom CSS, design tokens
  </Card>
  <Card title="testing/vitest" href="/commands/add">
    Test naming, coverage, mocks
  </Card>
  <Card title="security/supabase-rls" href="/commands/add">
    RLS enforcement, auth patterns
  </Card>
</Columns>

**Open source · MIT license · 4 dependencies**

[Get Started →](/quickstart)
